//@version=6
// -----------------------------------------------------------------------------
// Strategy Summary: LTF Liquidity Sweep with HTF Structure Stops
//
// 1) Structure mapping:
//    - Builds pivot-high/pivot-low horizontal levels on both LTF (chart TF)
//      and a configurable HTF.
//    - Uses 3 line states:
//      - BLACK: normal pivot level
//      - PURPLE: pivot formed after same-side sweep context
//      - RED: confirmed when paired pivots are followed by >3 ATR move-away
//
// 2) RED level creation logic:
//    - Pairs nearby pivots (within ATR-based tolerance).
//    - When price moves away from the paired liquidity zone by >3 ATR,
//      both paired levels are promoted to RED.
//
// 3) Entry trigger logic (LTF only):
//    - SHORT trigger when price sweeps an active RED LTF high.
//    - LONG trigger when price sweeps an active RED LTF low.
//    - Only enters when flat (no pyramiding).
//
// 4) Risk model and exits:
//    - Stop-loss is anchored to nearest HTF PURPLE level:
//      - SHORT: nearest HTF purple high above entry
//      - LONG: nearest HTF purple low below entry
//    - A fixed 1-pip buffer is added to SL distance (further from entry).
//    - Additional safety filter: no active RED level may exist between
//      entry price and stop-loss (across all LTF/HTF high/low pools).
//    - Take-profit is the nearest HTF RED level in trade direction.
//    - Trade is only allowed when reward:risk is within configured min/max.
//    - Force-exit if nearest active line above price is PURPLE while long,
//      or nearest active line below price is PURPLE while short.
//    - For force-exit scan, BLACK lines are ignored.
//    - Position size uses fixed risk: 1% of initial capital / stop distance.
//
// 5) Visualization/runtime management:
//    - Keeps separate line pools for LTF/HTF highs and lows.
//    - Trims old lines to stay within TradingView max line limits.
//    - Stops extending levels once they are breached.
//    - Draws TP (green) and SL (blue) boxes from entry until trade close.
// -----------------------------------------------------------------------------
strategy("LTF Liquidity Sweep Strategy (with HTF lines kept)", overlay=true,
     initial_capital=100000,
     pyramiding=0,
     default_qty_type=strategy.fixed,
     commission_type=strategy.commission.cash_per_contract,
     commission_value=2.5/100000,
     margin_short = 1,
     margin_long = 1,
     max_lines_count=500,
     max_boxes_count=500)

//============================
// Fixed (non-tunable) settings
//============================
const int   LTF_PIVOT_LEN  = 3
const int   HTF_PIVOT_LEN  = 3
const int   ATR_LEN    = 14
const float SL_BUFFER_PIPS = 1.0
const float LIQ_MOVE_AWAY_ATR = 3.0

// Total line budget = 500 across ALL lines drawn.
// Split across 4 pools (LTF H/L + HTF H/L) => 150+150+100+100 = 500
const int   MAX_LTF_H  = 150
const int   MAX_LTF_L  = 150
const int   MAX_HTF_H  = 100
const int   MAX_HTF_L  = 100

// Strategy params
const float RISK_PCT    = 0.01
htf = input.timeframe("60", "HTF")
showLTF = input.bool(true, "Show LTF High/Low lines")
showHTF = input.bool(true, "Show HTF High/Low lines")

// Tunable params
minRR = input.float(2.0, "Min Reward:Risk", minval=0.0, step=0.1)
maxRR = input.float(10.0, "Max Reward:Risk", minval=0.0, step=0.1)
atrDistForLiqGeneration = input.float(1.0, "ATR Distance For Liquidity Generation", minval=0.0, step=0.1)

// Line state encoding
const int ST_BLACK  = 0
const int ST_PURPLE = 1
const int ST_RED    = 2

//============================
// Common helper
//============================
f_both_active(bool[] actArr, int a, int b) =>
    a >= 0 and b >= 0 and a < array.size(actArr) and b < array.size(actArr) and array.get(actArr, a) and array.get(actArr, b)

// Check if any ACTIVE RED line (LTF or HTF, high or low) exists between p1 and p2 (exclusive)
f_any_red_between(float p1, float p2,
                  float[] ltfH_lvls, bool[] ltfH_drawnAct, int[] ltfH_state,
                  float[] ltfL_lvls, bool[] ltfL_drawnAct, int[] ltfL_state,
                  float[] htfH_lvls, bool[] htfH_drawnAct, int[] htfH_state,
                  float[] htfL_lvls, bool[] htfL_drawnAct, int[] htfL_state) =>
    float lo = math.min(p1, p2)
    float hi = math.max(p1, p2)
    bool found = false

    int n1 = array.size(ltfH_lvls)
    if n1 > 0
        for i = 0 to n1 - 1
            if array.get(ltfH_drawnAct, i) and array.get(ltfH_state, i) == ST_RED
                float lvl = array.get(ltfH_lvls, i)
                if lvl > lo and lvl < hi
                    found := true
                    break

    int n2 = array.size(ltfL_lvls)
    if not found and n2 > 0
        for i = 0 to n2 - 1
            if array.get(ltfL_drawnAct, i) and array.get(ltfL_state, i) == ST_RED
                float lvl = array.get(ltfL_lvls, i)
                if lvl > lo and lvl < hi
                    found := true
                    break

    int n3 = array.size(htfH_lvls)
    if not found and n3 > 0
        for i = 0 to n3 - 1
            if array.get(htfH_drawnAct, i) and array.get(htfH_state, i) == ST_RED
                float lvl = array.get(htfH_lvls, i)
                if lvl > lo and lvl < hi
                    found := true
                    break

    int n4 = array.size(htfL_lvls)
    if not found and n4 > 0
        for i = 0 to n4 - 1
            if array.get(htfL_drawnAct, i) and array.get(htfL_state, i) == ST_RED
                float lvl = array.get(htfL_lvls, i)
                if lvl > lo and lvl < hi
                    found := true
                    break

    found

// Find state of nearest ACTIVE NON-BLACK line ABOVE price across LTF/HTF high/low pools.
// Returns -1 when no active non-black line above exists.
f_next_state_above(float price,
                   float[] ltfH_lvls, bool[] ltfH_drawnAct, int[] ltfH_state,
                   float[] ltfL_lvls, bool[] ltfL_drawnAct, int[] ltfL_state,
                   float[] htfH_lvls, bool[] htfH_drawnAct, int[] htfH_state,
                   float[] htfL_lvls, bool[] htfL_drawnAct, int[] htfL_state) =>
    float bestLvl = na
    int bestState = -1

    int n1 = array.size(ltfH_lvls)
    if n1 > 0
        for i = 0 to n1 - 1
            if array.get(ltfH_drawnAct, i)
                float lvl = array.get(ltfH_lvls, i)
                int st = array.get(ltfH_state, i)
                if st != ST_BLACK and lvl > price and (na(bestLvl) or lvl < bestLvl)
                    bestLvl := lvl
                    bestState := st

    int n2 = array.size(ltfL_lvls)
    if n2 > 0
        for i = 0 to n2 - 1
            if array.get(ltfL_drawnAct, i)
                float lvl = array.get(ltfL_lvls, i)
                int st = array.get(ltfL_state, i)
                if st != ST_BLACK and lvl > price and (na(bestLvl) or lvl < bestLvl)
                    bestLvl := lvl
                    bestState := st

    int n3 = array.size(htfH_lvls)
    if n3 > 0
        for i = 0 to n3 - 1
            if array.get(htfH_drawnAct, i)
                float lvl = array.get(htfH_lvls, i)
                int st = array.get(htfH_state, i)
                if st != ST_BLACK and lvl > price and (na(bestLvl) or lvl < bestLvl)
                    bestLvl := lvl
                    bestState := st

    int n4 = array.size(htfL_lvls)
    if n4 > 0
        for i = 0 to n4 - 1
            if array.get(htfL_drawnAct, i)
                float lvl = array.get(htfL_lvls, i)
                int st = array.get(htfL_state, i)
                if st != ST_BLACK and lvl > price and (na(bestLvl) or lvl < bestLvl)
                    bestLvl := lvl
                    bestState := st

    bestState

// Find state of nearest ACTIVE NON-BLACK line BELOW price across LTF/HTF high/low pools.
// Returns -1 when no active non-black line below exists.
f_next_state_below(float price,
                   float[] ltfH_lvls, bool[] ltfH_drawnAct, int[] ltfH_state,
                   float[] ltfL_lvls, bool[] ltfL_drawnAct, int[] ltfL_state,
                   float[] htfH_lvls, bool[] htfH_drawnAct, int[] htfH_state,
                   float[] htfL_lvls, bool[] htfL_drawnAct, int[] htfL_state) =>
    float bestLvl = na
    int bestState = -1

    int n1 = array.size(ltfH_lvls)
    if n1 > 0
        for i = 0 to n1 - 1
            if array.get(ltfH_drawnAct, i)
                float lvl = array.get(ltfH_lvls, i)
                int st = array.get(ltfH_state, i)
                if st != ST_BLACK and lvl < price and (na(bestLvl) or lvl > bestLvl)
                    bestLvl := lvl
                    bestState := st

    int n2 = array.size(ltfL_lvls)
    if n2 > 0
        for i = 0 to n2 - 1
            if array.get(ltfL_drawnAct, i)
                float lvl = array.get(ltfL_lvls, i)
                int st = array.get(ltfL_state, i)
                if st != ST_BLACK and lvl < price and (na(bestLvl) or lvl > bestLvl)
                    bestLvl := lvl
                    bestState := st

    int n3 = array.size(htfH_lvls)
    if n3 > 0
        for i = 0 to n3 - 1
            if array.get(htfH_drawnAct, i)
                float lvl = array.get(htfH_lvls, i)
                int st = array.get(htfH_state, i)
                if st != ST_BLACK and lvl < price and (na(bestLvl) or lvl > bestLvl)
                    bestLvl := lvl
                    bestState := st

    int n4 = array.size(htfL_lvls)
    if n4 > 0
        for i = 0 to n4 - 1
            if array.get(htfL_drawnAct, i)
                float lvl = array.get(htfL_lvls, i)
                int st = array.get(htfL_state, i)
                if st != ST_BLACK and lvl < price and (na(bestLvl) or lvl > bestLvl)
                    bestLvl := lvl
                    bestState := st

    bestState

// Find next HTF PURPLE high ABOVE price (nearest). Returns na if none.
f_next_htf_purple_high_above(float price, float[] htfH_lvls, bool[] htfH_drawnAct, int[] htfH_state) =>
    float best = na
    int n = array.size(htfH_lvls)
    if n > 0
        for i = 0 to n - 1
            if array.get(htfH_drawnAct, i) and array.get(htfH_state, i) == ST_PURPLE
                float lvl = array.get(htfH_lvls, i)
                if lvl > price
                    best := na(best) ? lvl : math.min(best, lvl)
    best

// Find next HTF PURPLE low BELOW price (nearest). Returns na if none.
f_next_htf_purple_low_below(float price, float[] htfL_lvls, bool[] htfL_drawnAct, int[] htfL_state) =>
    float best = na
    int n = array.size(htfL_lvls)
    if n > 0
        for i = 0 to n - 1
            if array.get(htfL_drawnAct, i) and array.get(htfL_state, i) == ST_PURPLE
                float lvl = array.get(htfL_lvls, i)
                if lvl < price
                    best := na(best) ? lvl : math.max(best, lvl) // closest below
    best

// Find next HTF RED level ABOVE price (nearest across HTF highs + lows). Returns na if none.
f_next_htf_red_above(float price,
                     float[] htfH_lvls, bool[] htfH_drawnAct, int[] htfH_state,
                     float[] htfL_lvls, bool[] htfL_drawnAct, int[] htfL_state) =>
    float best = na
    int nH = array.size(htfH_lvls)
    if nH > 0
        for i = 0 to nH - 1
            if array.get(htfH_drawnAct, i) and array.get(htfH_state, i) == ST_RED
                float lvl = array.get(htfH_lvls, i)
                if lvl > price
                    best := na(best) ? lvl : math.min(best, lvl)

    int nL = array.size(htfL_lvls)
    if nL > 0
        for i = 0 to nL - 1
            if array.get(htfL_drawnAct, i) and array.get(htfL_state, i) == ST_RED
                float lvl = array.get(htfL_lvls, i)
                if lvl > price
                    best := na(best) ? lvl : math.min(best, lvl)
    best

// Find next HTF RED level BELOW price (nearest across HTF highs + lows). Returns na if none.
f_next_htf_red_below(float price,
                     float[] htfH_lvls, bool[] htfH_drawnAct, int[] htfH_state,
                     float[] htfL_lvls, bool[] htfL_drawnAct, int[] htfL_state) =>
    float best = na
    int nH = array.size(htfH_lvls)
    if nH > 0
        for i = 0 to nH - 1
            if array.get(htfH_drawnAct, i) and array.get(htfH_state, i) == ST_RED
                float lvl = array.get(htfH_lvls, i)
                if lvl < price
                    best := na(best) ? lvl : math.max(best, lvl)

    int nL = array.size(htfL_lvls)
    if nL > 0
        for i = 0 to nL - 1
            if array.get(htfL_drawnAct, i) and array.get(htfL_state, i) == ST_RED
                float lvl = array.get(htfL_lvls, i)
                if lvl < price
                    best := na(best) ? lvl : math.max(best, lvl)
    best


//====================================================================
// LTF ENGINE (current chart TF): HIGH + LOW
//====================================================================
ltfATR = ta.atr(ATR_LEN)
ltfPH  = ta.pivothigh(high, LTF_PIVOT_LEN, LTF_PIVOT_LEN)
ltfPL  = ta.pivotlow(low,  LTF_PIVOT_LEN, LTF_PIVOT_LEN)

ltfPivotTime = time[LTF_PIVOT_LEN]
ltfPivotATR  = ltfATR[LTF_PIVOT_LEN]

//----------------------------
// LTF High storage
//----------------------------
var line[]  ltfH_lines      = array.new_line()
var float[] ltfH_lvls       = array.new_float()
var bool[]  ltfH_act        = array.new_bool()
var int[]   ltfH_breachTime = array.new_int()
var bool[]  ltfH_drawnAct   = array.new_bool()
var int[]   ltfH_state      = array.new_int()

var int[]   ltfH_pendA      = array.new_int()
var int[]   ltfH_pendB      = array.new_int()
var float[] ltfH_pendTriggerDown = array.new_float()
var bool[]  ltfH_pendOk     = array.new_bool()

ltfH_trim() =>
    bool trimmed = false
    if array.size(ltfH_lines) > MAX_LTF_H
        trimmed := true
        line old = array.get(ltfH_lines, 0)
        line.delete(old)

        array.remove(ltfH_lines, 0)
        array.remove(ltfH_lvls,  0)
        array.remove(ltfH_act,   0)
        array.remove(ltfH_breachTime, 0)
        array.remove(ltfH_drawnAct, 0)
        array.remove(ltfH_state, 0)

        int pn = array.size(ltfH_pendA)
        if pn > 0
            for k = pn - 1 to 0
                int a = array.get(ltfH_pendA, k)
                int b = array.get(ltfH_pendB, k)
                if a == 0 or b == 0
                    array.remove(ltfH_pendA, k)
                    array.remove(ltfH_pendB, k)
                    array.remove(ltfH_pendTriggerDown, k)
                    array.remove(ltfH_pendOk, k)
                else
                    array.set(ltfH_pendA, k, a - 1)
                    array.set(ltfH_pendB, k, b - 1)
    trimmed

//----------------------------
// LTF Low storage
//----------------------------
var line[]  ltfL_lines      = array.new_line()
var float[] ltfL_lvls       = array.new_float()
var bool[]  ltfL_act        = array.new_bool()
var int[]   ltfL_breachTime = array.new_int()
var bool[]  ltfL_drawnAct   = array.new_bool()
var int[]   ltfL_state      = array.new_int()

var int[]   ltfL_pendA       = array.new_int()
var int[]   ltfL_pendB       = array.new_int()
var float[] ltfL_pendTriggerUp = array.new_float()
var bool[]  ltfL_pendOk      = array.new_bool()

ltfL_trim() =>
    bool trimmed = false
    if array.size(ltfL_lines) > MAX_LTF_L
        trimmed := true
        line old = array.get(ltfL_lines, 0)
        line.delete(old)

        array.remove(ltfL_lines, 0)
        array.remove(ltfL_lvls,  0)
        array.remove(ltfL_act,   0)
        array.remove(ltfL_breachTime, 0)
        array.remove(ltfL_drawnAct, 0)
        array.remove(ltfL_state, 0)

        int pn = array.size(ltfL_pendA)
        if pn > 0
            for k = pn - 1 to 0
                int a = array.get(ltfL_pendA, k)
                int b = array.get(ltfL_pendB, k)
                if a == 0 or b == 0
                    array.remove(ltfL_pendA, k)
                    array.remove(ltfL_pendB, k)
                    array.remove(ltfL_pendTriggerUp, k)
                    array.remove(ltfL_pendOk, k)
                else
                    array.set(ltfL_pendA, k, a - 1)
                    array.set(ltfL_pendB, k, b - 1)
    trimmed


//============================
// LTF: breach tracking (for purple detection)
//============================
if showLTF
    int ltfHn = array.size(ltfH_lvls)
    if ltfHn > 0
        for i = 0 to ltfHn - 1
            if array.get(ltfH_act, i)
                float lvl = array.get(ltfH_lvls, i)
                if high > lvl
                    array.set(ltfH_act, i, false)
                    array.set(ltfH_breachTime, i, time)

    int ltfLn = array.size(ltfL_lvls)
    if ltfLn > 0
        for i = 0 to ltfLn - 1
            if array.get(ltfL_act, i)
                float lvl = array.get(ltfL_lvls, i)
                if low < lvl
                    array.set(ltfL_act, i, false)
                    array.set(ltfL_breachTime, i, time)


//============================
// LTF: new pivot HIGH line
//============================
if showLTF and not na(ltfPH)
    int pTime = ltfPivotTime
    float pATR = ltfPivotATR

    bool sweptEarlier = false
    int nb = array.size(ltfH_breachTime)
    if nb > 0
        for j = nb - 1 to 0
            if array.get(ltfH_breachTime, j) == pTime
                sweptEarlier := true
                break

    int match = na
    float matchLvl = na
    int n = array.size(ltfH_lvls)
    if n > 0
        for j = n - 1 to 0
            if array.get(ltfH_act, j)
                float prev = array.get(ltfH_lvls, j)
                if math.abs(ltfPH - prev) <= (atrDistForLiqGeneration * pATR) and ltfPH <= prev
                    match := j
                    matchLvl := prev
                    break

    int baseState = sweptEarlier ? ST_PURPLE : ST_BLACK
    color baseCol = sweptEarlier ? color.purple : color.black

    line ln = line.new(x1=pTime, y1=ltfPH, x2=time, y2=ltfPH, xloc=xloc.bar_time, extend=extend.right, color=baseCol, width=1)

    int currIdx = array.size(ltfH_lines)
    array.push(ltfH_lines, ln)
    array.push(ltfH_lvls,  ltfPH)
    array.push(ltfH_act,   true)
    array.push(ltfH_breachTime, na)
    array.push(ltfH_drawnAct, true)
    array.push(ltfH_state, baseState)

    if not na(match)
        array.push(ltfH_pendA, match)
        array.push(ltfH_pendB, currIdx)
        float pairHigh = math.max(ltfPH, matchLvl)
        float triggerDown = pairHigh - (LIQ_MOVE_AWAY_ATR * pATR)
        array.push(ltfH_pendTriggerDown, triggerDown)
        array.push(ltfH_pendOk, false)

    _ = ltfH_trim()


//============================
// LTF: new pivot LOW line
//============================
if showLTF and not na(ltfPL)
    int pTime = ltfPivotTime
    float pATR = ltfPivotATR

    bool sweptEarlier = false
    int nb = array.size(ltfL_breachTime)
    if nb > 0
        for j = nb - 1 to 0
            if array.get(ltfL_breachTime, j) == pTime
                sweptEarlier := true
                break

    int match = na
    float matchLvl = na
    int n = array.size(ltfL_lvls)
    if n > 0
        for j = n - 1 to 0
            if array.get(ltfL_act, j)
                float prev = array.get(ltfL_lvls, j)
                if math.abs(ltfPL - prev) <= (atrDistForLiqGeneration * pATR) and ltfPL >= prev
                    match := j
                    matchLvl := prev
                    break

    int baseState = sweptEarlier ? ST_PURPLE : ST_BLACK
    color baseCol = sweptEarlier ? color.purple : color.black

    line ln = line.new(x1=pTime, y1=ltfPL, x2=time, y2=ltfPL, xloc=xloc.bar_time, extend=extend.right, color=baseCol, width=1)

    int currIdx = array.size(ltfL_lines)
    array.push(ltfL_lines, ln)
    array.push(ltfL_lvls,  ltfPL)
    array.push(ltfL_act,   true)
    array.push(ltfL_breachTime, na)
    array.push(ltfL_drawnAct, true)
    array.push(ltfL_state, baseState)

    if not na(match)
        array.push(ltfL_pendA, match)
        array.push(ltfL_pendB, currIdx)
        float pairLow = math.min(ltfPL, matchLvl)
        float triggerUp = pairLow + (LIQ_MOVE_AWAY_ATR * pATR)
        array.push(ltfL_pendTriggerUp, triggerUp)
        array.push(ltfL_pendOk, false)

    _ = ltfL_trim()


//============================
// LTF: move-away confirmations -> RED (updates state arrays too)
//============================
if showLTF
    int pnH = array.size(ltfH_pendA)
    if pnH > 0
        for k = 0 to pnH - 1
            if not array.get(ltfH_pendOk, k)
                float triggerDown = array.get(ltfH_pendTriggerDown, k)
                if close <= triggerDown
                    int a = array.get(ltfH_pendA, k)
                    int b = array.get(ltfH_pendB, k)
                    if f_both_active(ltfH_act, a, b)
                        line.set_color(array.get(ltfH_lines, a), color.red)
                        line.set_color(array.get(ltfH_lines, b), color.red)
                        array.set(ltfH_state, a, ST_RED)
                        array.set(ltfH_state, b, ST_RED)
                        array.set(ltfH_pendOk, k, true)
                        break

    int pnL = array.size(ltfL_pendA)
    if pnL > 0
        for k = 0 to pnL - 1
            if not array.get(ltfL_pendOk, k)
                float triggerUp = array.get(ltfL_pendTriggerUp, k)
                if close >= triggerUp
                    int a = array.get(ltfL_pendA, k)
                    int b = array.get(ltfL_pendB, k)
                    if f_both_active(ltfL_act, a, b)
                        line.set_color(array.get(ltfL_lines, a), color.red)
                        line.set_color(array.get(ltfL_lines, b), color.red)
                        array.set(ltfL_state, a, ST_RED)
                        array.set(ltfL_state, b, ST_RED)
                        array.set(ltfL_pendOk, k, true)
                        break


//============================
// LTF: Stop extending on breach (visual) and build sweep triggers
//============================
bool trigShort = false
bool trigLong  = false

if showLTF
    // High sweep trigger: RED high breached
    int nnH = array.size(ltfH_lines)
    if nnH > 0
        for i = 0 to nnH - 1
            if array.get(ltfH_drawnAct, i)
                float lvl = array.get(ltfH_lvls, i)
                if high > lvl
                    if array.get(ltfH_state, i) == ST_RED
                        trigShort := true
                    line ln = array.get(ltfH_lines, i)
                    line.set_extend(ln, extend.none)
                    line.set_x2(ln, time)
                    array.set(ltfH_drawnAct, i, false)
                    if trigShort
                        break

    // Low sweep trigger: RED low breached
    int nnL = array.size(ltfL_lines)
    if nnL > 0 and not trigShort
        for i = 0 to nnL - 1
            if array.get(ltfL_drawnAct, i)
                float lvl = array.get(ltfL_lvls, i)
                if low < lvl
                    if array.get(ltfL_state, i) == ST_RED
                        trigLong := true
                    line ln = array.get(ltfL_lines, i)
                    line.set_extend(ln, extend.none)
                    line.set_x2(ln, time)
                    array.set(ltfL_drawnAct, i, false)
                    if trigLong
                        break


//====================================================================
// HTF ENGINE (kept; not used for entries except SL selection)
//====================================================================
htfHigh  = request.security(syminfo.tickerid, htf, high,  barmerge.gaps_off, barmerge.lookahead_off)
htfLow   = request.security(syminfo.tickerid, htf, low,   barmerge.gaps_off, barmerge.lookahead_off)
htfClose = request.security(syminfo.tickerid, htf, close, barmerge.gaps_off, barmerge.lookahead_off)
htfTime  = request.security(syminfo.tickerid, htf, time,  barmerge.gaps_off, barmerge.lookahead_off)

htfPH = request.security(syminfo.tickerid, htf, ta.pivothigh(high, HTF_PIVOT_LEN, HTF_PIVOT_LEN), barmerge.gaps_off, barmerge.lookahead_off)
htfPL = request.security(syminfo.tickerid, htf, ta.pivotlow(low,  HTF_PIVOT_LEN, HTF_PIVOT_LEN), barmerge.gaps_off, barmerge.lookahead_off)

htfPivotTime = request.security(syminfo.tickerid, htf, time[HTF_PIVOT_LEN], barmerge.gaps_off, barmerge.lookahead_off)
htfPivotATR  = request.security(syminfo.tickerid, htf, ta.atr(ATR_LEN)[HTF_PIVOT_LEN], barmerge.gaps_off, barmerge.lookahead_off)

newHTFBar = htfTime != htfTime[1]

// HTF High storage
var line[]  htfH_lines      = array.new_line()
var float[] htfH_lvls       = array.new_float()
var bool[]  htfH_act        = array.new_bool()
var int[]   htfH_breachTime = array.new_int()
var bool[]  htfH_drawnAct   = array.new_bool()
var int[]   htfH_state      = array.new_int()

var int[]   htfH_pendA      = array.new_int()
var int[]   htfH_pendB      = array.new_int()
var float[] htfH_pendTriggerDown = array.new_float()
var bool[]  htfH_pendOk     = array.new_bool()

htfH_trim() =>
    bool trimmed = false
    if array.size(htfH_lines) > MAX_HTF_H
        trimmed := true
        line old = array.get(htfH_lines, 0)
        line.delete(old)
        array.remove(htfH_lines, 0)
        array.remove(htfH_lvls,  0)
        array.remove(htfH_act,   0)
        array.remove(htfH_breachTime, 0)
        array.remove(htfH_drawnAct, 0)
        array.remove(htfH_state, 0)

        int pn = array.size(htfH_pendA)
        if pn > 0
            for k = pn - 1 to 0
                int a = array.get(htfH_pendA, k)
                int b = array.get(htfH_pendB, k)
                if a == 0 or b == 0
                    array.remove(htfH_pendA, k)
                    array.remove(htfH_pendB, k)
                    array.remove(htfH_pendTriggerDown, k)
                    array.remove(htfH_pendOk, k)
                else
                    array.set(htfH_pendA, k, a - 1)
                    array.set(htfH_pendB, k, b - 1)
    trimmed

// HTF Low storage
var line[]  htfL_lines      = array.new_line()
var float[] htfL_lvls       = array.new_float()
var bool[]  htfL_act        = array.new_bool()
var int[]   htfL_breachTime = array.new_int()
var bool[]  htfL_drawnAct   = array.new_bool()
var int[]   htfL_state      = array.new_int()

var int[]   htfL_pendA       = array.new_int()
var int[]   htfL_pendB       = array.new_int()
var float[] htfL_pendTriggerUp = array.new_float()
var bool[]  htfL_pendOk      = array.new_bool()

htfL_trim() =>
    bool trimmed = false
    if array.size(htfL_lines) > MAX_HTF_L
        trimmed := true
        line old = array.get(htfL_lines, 0)
        line.delete(old)
        array.remove(htfL_lines, 0)
        array.remove(htfL_lvls,  0)
        array.remove(htfL_act,   0)
        array.remove(htfL_breachTime, 0)
        array.remove(htfL_drawnAct, 0)
        array.remove(htfL_state, 0)

        int pn = array.size(htfL_pendA)
        if pn > 0
            for k = pn - 1 to 0
                int a = array.get(htfL_pendA, k)
                int b = array.get(htfL_pendB, k)
                if a == 0 or b == 0
                    array.remove(htfL_pendA, k)
                    array.remove(htfL_pendB, k)
                    array.remove(htfL_pendTriggerUp, k)
                    array.remove(htfL_pendOk, k)
                else
                    array.set(htfL_pendA, k, a - 1)
                    array.set(htfL_pendB, k, b - 1)
    trimmed


//============================
// HTF update block
//============================
if showHTF and newHTFBar
    // breach tracking for purple detection (HTF side)
    int nH = array.size(htfH_lvls)
    if nH > 0
        for i = 0 to nH - 1
            if array.get(htfH_act, i)
                float lvl = array.get(htfH_lvls, i)
                if htfHigh > lvl
                    array.set(htfH_act, i, false)
                    array.set(htfH_breachTime, i, htfTime)

    int nL = array.size(htfL_lvls)
    if nL > 0
        for i = 0 to nL - 1
            if array.get(htfL_act, i)
                float lvl = array.get(htfL_lvls, i)
                if htfLow < lvl
                    array.set(htfL_act, i, false)
                    array.set(htfL_breachTime, i, htfTime)

    // new HTF pivot HIGH line
    if not na(htfPH)
        int pTime = htfPivotTime
        float pATR = htfPivotATR

        bool sweptEarlier = false
        int nb = array.size(htfH_breachTime)
        if nb > 0
            for j = nb - 1 to 0
                if array.get(htfH_breachTime, j) == pTime
                    sweptEarlier := true
                    break

        int match = na
        float matchLvl = na
        int n = array.size(htfH_lvls)
        if n > 0
            for j = n - 1 to 0
                if array.get(htfH_act, j)
                    float prev = array.get(htfH_lvls, j)
                    if math.abs(htfPH - prev) <= (atrDistForLiqGeneration * pATR) and htfPH <= prev
                        match := j
                        matchLvl := prev
                        break

        int baseState = sweptEarlier ? ST_PURPLE : ST_BLACK
        color baseCol = sweptEarlier ? color.purple : color.black

        line ln = line.new(x1=pTime, y1=htfPH, x2=time, y2=htfPH, xloc=xloc.bar_time, extend=extend.right, color=baseCol, width=2)

        int currIdx = array.size(htfH_lines)
        array.push(htfH_lines, ln)
        array.push(htfH_lvls,  htfPH)
        array.push(htfH_act,   true)
        array.push(htfH_breachTime, na)
        array.push(htfH_drawnAct, true)
        array.push(htfH_state, baseState)

        if not na(match)
            array.push(htfH_pendA, match)
            array.push(htfH_pendB, currIdx)
            float pairHigh = math.max(htfPH, matchLvl)
            float triggerDown = pairHigh - (LIQ_MOVE_AWAY_ATR * pATR)
            array.push(htfH_pendTriggerDown, triggerDown)
            array.push(htfH_pendOk, false)

        _ = htfH_trim()

    // new HTF pivot LOW line
    if not na(htfPL)
        int pTime = htfPivotTime
        float pATR = htfPivotATR

        bool sweptEarlier = false
        int nb = array.size(htfL_breachTime)
        if nb > 0
            for j = nb - 1 to 0
                if array.get(htfL_breachTime, j) == pTime
                    sweptEarlier := true
                    break

        int match = na
        float matchLvl = na
        int n = array.size(htfL_lvls)
        if n > 0
            for j = n - 1 to 0
                if array.get(htfL_act, j)
                    float prev = array.get(htfL_lvls, j)
                    if math.abs(htfPL - prev) <= (atrDistForLiqGeneration * pATR) and htfPL >= prev
                        match := j
                        matchLvl := prev
                        break

        int baseState = sweptEarlier ? ST_PURPLE : ST_BLACK
        color baseCol = sweptEarlier ? color.purple : color.black

        line ln = line.new(x1=pTime, y1=htfPL, x2=time, y2=htfPL, xloc=xloc.bar_time, extend=extend.right, color=baseCol, width=2)

        int currIdx = array.size(htfL_lines)
        array.push(htfL_lines, ln)
        array.push(htfL_lvls,  htfPL)
        array.push(htfL_act,   true)
        array.push(htfL_breachTime, na)
        array.push(htfL_drawnAct, true)
        array.push(htfL_state, baseState)

        if not na(match)
            array.push(htfL_pendA, match)
            array.push(htfL_pendB, currIdx)
            float pairLow = math.min(htfPL, matchLvl)
            float triggerUp = pairLow + (LIQ_MOVE_AWAY_ATR * pATR)
            array.push(htfL_pendTriggerUp, triggerUp)
            array.push(htfL_pendOk, false)

        _ = htfL_trim()

    // HTF move-away confirmations -> RED (also updates state arrays)
    int pnHH = array.size(htfH_pendA)
    if pnHH > 0
        for k = 0 to pnHH - 1
            if not array.get(htfH_pendOk, k)
                float triggerDown = array.get(htfH_pendTriggerDown, k)
                if htfClose <= triggerDown
                    int a = array.get(htfH_pendA, k)
                    int b = array.get(htfH_pendB, k)
                    if f_both_active(htfH_act, a, b)
                        line.set_color(array.get(htfH_lines, a), color.red)
                        line.set_color(array.get(htfH_lines, b), color.red)
                        array.set(htfH_state, a, ST_RED)
                        array.set(htfH_state, b, ST_RED)
                        array.set(htfH_pendOk, k, true)
                        break

    int pnLL = array.size(htfL_pendA)
    if pnLL > 0
        for k = 0 to pnLL - 1
            if not array.get(htfL_pendOk, k)
                float triggerUp = array.get(htfL_pendTriggerUp, k)
                if htfClose >= triggerUp
                    int a = array.get(htfL_pendA, k)
                    int b = array.get(htfL_pendB, k)
                    if f_both_active(htfL_act, a, b)
                        line.set_color(array.get(htfL_lines, a), color.red)
                        line.set_color(array.get(htfL_lines, b), color.red)
                        array.set(htfL_state, a, ST_RED)
                        array.set(htfL_state, b, ST_RED)
                        array.set(htfL_pendOk, k, true)
                        break

// HTF: stop extending on breach (visual on LTF chart)
if showHTF
    int nnHH = array.size(htfH_lines)
    if nnHH > 0
        for i = 0 to nnHH - 1
            if array.get(htfH_drawnAct, i)
                float lvl = array.get(htfH_lvls, i)
                if high > lvl
                    line ln = array.get(htfH_lines, i)
                    line.set_extend(ln, extend.none)
                    line.set_x2(ln, time)
                    array.set(htfH_drawnAct, i, false)

    int nnLL = array.size(htfL_lines)
    if nnLL > 0
        for i = 0 to nnLL - 1
            if array.get(htfL_drawnAct, i)
                float lvl = array.get(htfL_lvls, i)
                if low < lvl
                    line ln = array.get(htfL_lines, i)
                    line.set_extend(ln, extend.none)
                    line.set_x2(ln, time)
                    array.set(htfL_drawnAct, i, false)


//====================================================================
// STRATEGY ENTRIES
// Entry: LTF liquidity sweep (trigShort / trigLong)
// SL: next HTF purple line (above for shorts, below for longs)
// Constraint: NO active RED lines (LTF or HTF, H or L) between entry and SL
// TP: next HTF RED line in TP direction (below for shorts, above for longs)
// Constraint: reward:risk must be > minRR and <= maxRR
// SL uses +1 pip buffer beyond structural stop.
// Force-exit: if nearest line above (long) / below (short) is PURPLE.
// Risk sizing: 1% of initial capital
//====================================================================
bool flat = strategy.position_size == 0
float entryPx = close
bool rrBandValid = maxRR > minRR
float pipSize = syminfo.type == "forex" ? (syminfo.currency == "JPY" ? 0.01 : 0.0001) : syminfo.mintick
float slBuffer = SL_BUFFER_PIPS * pipSize
var float pendingSL = na
var float pendingTP = na
var bool pendingVisual = false
var box activeTpBox = na
var box activeSlBox = na

if flat and trigShort
    float slRaw = f_next_htf_purple_high_above(entryPx, htfH_lvls, htfH_drawnAct, htfH_state)
    float sl = na(slRaw) ? na : (slRaw + slBuffer)
    float tp = f_next_htf_red_below(
         entryPx,
         htfH_lvls, htfH_drawnAct, htfH_state,
         htfL_lvls, htfL_drawnAct, htfL_state)
    bool okSL = not na(sl) and sl > entryPx
    bool okTP = not na(tp) and tp < entryPx
    float riskDist = okSL ? (sl - entryPx) : na
    float rewardDist = okTP ? (entryPx - tp) : na
    float rr = (not na(riskDist) and riskDist > 0 and not na(rewardDist)) ? (rewardDist / riskDist) : na
    bool okRR = rrBandValid and not na(rr) and rr > minRR and rr <= maxRR
    bool hasRedBetween = okSL ? f_any_red_between(entryPx, sl,
         ltfH_lvls, ltfH_drawnAct, ltfH_state,
         ltfL_lvls, ltfL_drawnAct, ltfL_state,
         htfH_lvls, htfH_drawnAct, htfH_state,
         htfL_lvls, htfL_drawnAct, htfL_state) : true

    if okSL and okTP and okRR and not hasRedBetween
        float riskAmount = strategy.initial_capital * RISK_PCT
        float stopDist = math.max(sl - entryPx, syminfo.mintick)
        float qty = riskAmount / stopDist

        strategy.entry("S", strategy.short, qty=qty)
        strategy.exit("S-exit", from_entry="S", stop=sl, limit=tp)
        pendingSL := sl
        pendingTP := tp
        pendingVisual := true

if flat and trigLong
    float slRaw = f_next_htf_purple_low_below(entryPx, htfL_lvls, htfL_drawnAct, htfL_state)
    float sl = na(slRaw) ? na : (slRaw - slBuffer)
    float tp = f_next_htf_red_above(
         entryPx,
         htfH_lvls, htfH_drawnAct, htfH_state,
         htfL_lvls, htfL_drawnAct, htfL_state)
    bool okSL = not na(sl) and sl < entryPx
    bool okTP = not na(tp) and tp > entryPx
    float riskDist = okSL ? (entryPx - sl) : na
    float rewardDist = okTP ? (tp - entryPx) : na
    float rr = (not na(riskDist) and riskDist > 0 and not na(rewardDist)) ? (rewardDist / riskDist) : na
    bool okRR = rrBandValid and not na(rr) and rr > minRR and rr <= maxRR
    bool hasRedBetween = okSL ? f_any_red_between(entryPx, sl,
         ltfH_lvls, ltfH_drawnAct, ltfH_state,
         ltfL_lvls, ltfL_drawnAct, ltfL_state,
         htfH_lvls, htfH_drawnAct, htfH_state,
         htfL_lvls, htfL_drawnAct, htfL_state) : true

    if okSL and okTP and okRR and not hasRedBetween
        float riskAmount = strategy.initial_capital * RISK_PCT
        float stopDist = math.max(entryPx - sl, syminfo.mintick)
        float qty = riskAmount / stopDist

        strategy.entry("L", strategy.long, qty=qty)
        strategy.exit("L-exit", from_entry="L", stop=sl, limit=tp)
        pendingSL := sl
        pendingTP := tp
        pendingVisual := true

// Directional force-exit when nearest line in trade direction is PURPLE.
if strategy.position_size > 0
    int nextStateAbove = f_next_state_above(close,
         ltfH_lvls, ltfH_drawnAct, ltfH_state,
         ltfL_lvls, ltfL_drawnAct, ltfL_state,
         htfH_lvls, htfH_drawnAct, htfH_state,
         htfL_lvls, htfL_drawnAct, htfL_state)
    if nextStateAbove == ST_PURPLE
        strategy.close("L", comment="Nearest above is purple")

if strategy.position_size < 0
    int nextStateBelow = f_next_state_below(close,
         ltfH_lvls, ltfH_drawnAct, ltfH_state,
         ltfL_lvls, ltfL_drawnAct, ltfL_state,
         htfH_lvls, htfH_drawnAct, htfH_state,
         htfL_lvls, htfL_drawnAct, htfL_state)
    if nextStateBelow == ST_PURPLE
        strategy.close("S", comment="Nearest below is purple")

// Trade visual boxes: create on position open, extend while open, freeze on close.
bool openedPos = strategy.position_size != 0 and strategy.position_size[1] == 0
bool closedPos = strategy.position_size == 0 and strategy.position_size[1] != 0

if openedPos and pendingVisual and not na(pendingSL) and not na(pendingTP)
    float ep = strategy.position_avg_price
    float tpTop = math.max(ep, pendingTP)
    float tpBottom = math.min(ep, pendingTP)
    float slTop = math.max(ep, pendingSL)
    float slBottom = math.min(ep, pendingSL)

    activeTpBox := box.new(
         left=bar_index,
         top=tpTop,
         right=bar_index + 1,
         bottom=tpBottom,
         border_color=color.new(color.green, 0),
         bgcolor=color.new(color.green, 85),
         xloc=xloc.bar_index)
    activeSlBox := box.new(
         left=bar_index,
         top=slTop,
         right=bar_index + 1,
         bottom=slBottom,
         border_color=color.new(color.blue, 0),
         bgcolor=color.new(color.blue, 85),
         xloc=xloc.bar_index)
    pendingVisual := false

if strategy.position_size != 0
    if not na(activeTpBox)
        box.set_right(activeTpBox, bar_index + 1)
    if not na(activeSlBox)
        box.set_right(activeSlBox, bar_index + 1)

if closedPos
    if not na(activeTpBox)
        box.set_right(activeTpBox, bar_index)
    if not na(activeSlBox)
        box.set_right(activeSlBox, bar_index)
    activeTpBox := na
    activeSlBox := na
    pendingSL := na
    pendingTP := na
    pendingVisual := false
